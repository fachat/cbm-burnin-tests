
; order by preference which name should be displayed
#define	MODE_UPET	%10000000
#define	MODE_CSA	%01000000
#define	MODE_8296	%00100000
#define	MODE_40COL	%00010000
#define	MODE_2MHZ	%00001000
	

#define	SYSPORT		$efe0
#define	SYS_IRQEN	%00000010

#undef	FIX

tmp1	= $20			; general temp value for XOR, or adding
ptr1	= $21			; general pointer / 16 bit counter
ptr2	= $23			; general pointer / 16 bit counter
cnt	= $25			; general 8 bit counter

mode	= $26			; bit 7: 1=2 MHz
				; bit 6: 1=8296 detected
				; bit 5: 1=CS/A MMU detected

blkno	= $27			; block number for 8x96 test
memp1	= $28			; memory test pointer
pattrn	= $2a			; memory test pattern; will be increased each cycle (starts initialized by zp mem test)
screen	= $2b			; start of screen ptr
scrptr	= $2d			; current screen pointer
lineptr	= $2f			; start of current line
cols	= $31			; number of columns
revfl	= $32			; reverse flag
cycles	= $33			; 3 byte cycle counter

testp	= $36			; pointer to current test

	.word $0400
	* = $0400

	.byt 0
	.word link
	.word 10		; line number
	.byt $9e, "4096"
	.byt 0
link	.byt $00,$00

	.dsb 4096-*, $aa

l1000	; start of program

	sei

	; disable 8x96 mapping
	lda #$60
	sta $fff0

	;--------------------
	; check 1 vs 2 MHz


	.(
	; clear screen
l1016	ldy #$00
	lda #$20
l101a	sta $8000,y
	sta $8100,y
	sta $8200,y
	sta $8300,y
	sta $8400,y
	sta $8500,y
	sta $8600,y
	sta $8700,y
	iny
	bne l101a
	.)


#include "mod_zpstack.a65"

	.(

	; actual code to init
	ldx #$ff
	txs
	stx tmp1	; XOR value ($ff)
	jsr xcopy	; copy code to $200-$aff with XOR
	jsr xcomp	; check copied code
	bne l10b1
	inc tmp1	; next XOR value($00)
	jsr xcopy	
	jsr xcomp
	bne l10b1
l10ae	jmp $0200	; jump to code copied from $1162

        ; DIAGNOSTIC RAM BAD: BIT"
l1138   .byt "DIA"              ; $44,$49,$41
        .byt "GNO"              ; $47,$4e,$4f
        .byt "STI"              ; $53,$54,$49
        .byt "C R"              ; $43,$20,$52
        .byt "AM "              ; $41,$4d,$20
        .byt "BAD"              ; $42,$41,$44
        .byt ": B"              ; $3a,$20,$42
        .byt "IT", 0            ; $49,$54,$00

	; write error message to screen
l10b1	.(
	tax
l10b2	lda l1138,y
	beq enderr
	ora #$80
	sta $8000,y
	iny
	bne l10b2
	.)

	;.byt $f0,$c5	; TODO: remove

	; called from init (1)
	; copy code from $1162-1a61 to $0200-0aff
	; XORing bit with $20 in the process
xcopy	.(
	lda #<l1162	; $62
	sta ptr1
	lda #>l1162	; $11
	sta ptr1+1
	lda #$00
	sta ptr2
	lda #$02
	sta ptr2+1
	ldy #$00
l10d3	lda (ptr1),y
	eor tmp1
	sta (ptr2),y
	iny
	bne l10d3
l10dc	inc ptr1+1
	inc ptr2+1
	lda #>endofprg+255
	cmp ptr2+1
	bne l10d3
l10e6	rts
	.)

	; called from init (2)
	; compare the code from $1162-$1a61 with $0200-$0aff 
	; XORing with $20 in the process
	;
	; note that the caller actually checks the Z-flag,
	; but this is always set, as there is a program bug
	; in the error exit - it jumps to where LDY is cleared,
	; which sets the Z-flag. 
xcomp	.(
	lda #<l1162	; $62
	sta ptr1
	lda #>l1162	; $11
	sta ptr1+1
	lda #$00
	sta ptr2
	lda #$02
	sta ptr2+1
	ldy #$00
l10f9	lda (ptr1),y
	eor tmp1
	eor (ptr2),y
	bne l110e	; -> error exit
	iny
	bne l10f9
	inc ptr1+1
	inc ptr2+1
	lda #>endofprg+255
	eor ptr2+1
	bne l10f9
l110e	ldy #$00
	rts
	.)

	.)

	; --------------------------------------

	; CRTC init parameter
l1150 	.byt 126, 80, 100

	;.byt $3f,$28,$32
	.byt $31,$28,$29
	;.byt $05,$26,$01
	.byt $0f,$27,$00
	.byt $19,$20,$00	; ora !$0020,y
	;.byt $07,$20		; ora #$00
	.byt $09,$00		; ora #$00
	.byt $00
	.byt $10,$00		; bpl l115e
 	.byt $00,$00,$00
	.byt $00

	;=======================================
	; relocated code
	;
	; the following code is copied to $0200-...
	; So all addresses must be offset with $0f62

offset=0	;*-$0200

	; clear bytes 1950-1961 on 80 column screen?
l1162	
	*=$0200
	.(
	ldx #$0b
l1164	lda #$20
	sta $879e,x 
	dex
	bpl l1164
	.)

	;---------------------------------------
	; mode detection
	lda #0
	sta mode

	; CS/A detection
	.(
	lda #0
	sta SYSPORT
	cmp SYSPORT
	bne nocsa
	lda #SYS_IRQEN
	sta SYSPORT
	cmp SYSPORT
	bne nocsa

	lda mode
	ora #MODE_CSA
	sta mode
nocsa	.)


getfreq .(
	lda mode
	and #MODE_CSA
	beq endfrq
          lda #SYS_IRQEN
          sta SYSPORT
gf1       lda SYSPORT
          bpl gf1
          sta SYSPORT
          bit SYSPORT
          bmi gf1
          lda #0
          tay
          tax
gf2       bit SYSPORT
          bmi gfe
          clc
          adc #1
          bne gf2
          inx
          bne gf2
          iny
          bne gf2
gfe       cpx #8    ; more than 2 MHZ
          bcc endfrq
          lda #MODE_2MHZ
	ora mode
	sta mode
	; disable interrupt again
endfrq	lda #0
        sta SYSPORT
	.)


	;---------------------------------------
	; check for 8x96

	.(
	; save the interrupt/reset vectors
	ldx #$05
l116e	lda $fffa,x
	sta intvect-offset,x	; la73,x
	dex
	bpl l116e

	; enable 8x96 memory mapping
	lda #$80
	sta $fff0

	; compare interrupt/reset vectors
	ldx #$05
l117e	lda intvect-offset,x	; la73,x
	eor $fffa,x
	bne is8296
	dex
	bpl l117e
	bmi no8296
	
is8296 	; we have 8x96
	lda mode
	ora #MODE_8296
	sta mode
no8296	.)

	;---------------------------------------
	; check for 40/80 column PET
	.(
	lda mode
	and #MODE_CSA+MODE_UPET+MODE_8296
	bne no4032
	lda #0
	sta $8400
	cmp $8400
	bne is4032
	eor #$ff
	sta $8400
	cmp $8400
	beq no4032
is4032	lda mode
	ora #MODE_40COL
	sta mode
no4032	.)

	;---------------------------------------
	; put mode info on screen
	.(
	lda mode
	asl
	bcs upet
	asl
	bcs csa
	asl
	bcs c8296
	asl
	bcc nochg
c4032	ldy #m_4032-modes+3
	.byt $2c
c8296	ldy #m_8296-modes+3
	.byt $2c
upet	ldy #m_upet-modes+3
	.byt $2c
csa	ldy #m_csa-modes+3
	ldx #3
mloop	lda modes,y
	sta m_name,x
	dey
	dex
	bpl mloop
nochg	.)
	
	;---------------------------------------
	; to be replaced/removed
	.(
	lda mode
	and #MODE_2MHZ
	beq slow1
	; set CRTC and video
	ldy #$00
l1008	sty $e880
	lda l1150,y	; set CRTC parameters for 2MHz 80 col
	sta $e881
	iny
;	cpy #$12
	cpy #3
	bne l1008
slow1
	lda #14
	sta $e84c
	.)

	;---------------------------------------
	; all machines
l1193	lda #$60	; disable 8x96 mapping
	sta $fff0

	; init cycles counter
	lda #$00
	sta cycles
	sta cycles+1
	sta cycles+2

	; init start of screen for chrout
	lda #$80
	sta screen+1			; chrout scr hi ptr
	lda #$00
	sta screen			; chrout scr lo ptr

	; ------------------------------
	; clear screen
	lda #$93
	jsr chrout-offset	; l742

	; ------------------------------
	; output banner message
	.(
	lda #$28		; 40 column?
	sta cols

	lda #>initmsg-offset	;$09
	sta ptr1+1
	lda #<initmsg-offset	;$45
	sta ptr1
	ldy #$00
l11bb	lda (ptr1),y
	beq l11d8
	pha
	cmp #$13
	bne l11cc
	; on marker, move to $258 = char 600 = MIDDLE of line 7
	; to print the right column of diag messages
	lda #$82
	sta screen+1
	lda #$58
	sta screen
l11cc	pla
	jsr chrout-offset	; l742
	inc ptr1
	bne l11bb
l11d4	inc ptr1+1
	bne l11bb
	.)

	; ------------------------------
	; print out screen codes 0-255
l11d8	lda #$80
	sta scrptr+1	; screen ptr hi
	sta lineptr+1	; start of line
	sta screen+1	; chrout scr ptr hi
	lda #$a8
	sta scrptr	; screen ptr lo
	sta screen	; chrout scr ptr lo
	sta lineptr	; start of line
	lda #$40	; 64 columns?
	sta cols

	ldy #$00
	ldx #$00
l11f0	txa
	sta (scrptr),y	; store value on screen
	inx
	inc scrptr
	bne l11fa
l11f8	inc scrptr+1
l11fa	txa
	and #$3f	; end of line (64 values/line)
	bne l11f0

l11ff	lda #$0d
	jsr chrout-offset	;l742
	txa
	bne l11f0

	; ------------------------------
	; set IRQ routine

        ; set interrupt pointer to 08db
        lda #<irq-offset        ; $db
        sta $90
        lda #>irq-offset        ; $08
        sta $91

	; ------------------------------
	; test loop

loop	.(
	lda #<tests
	sta testp
	lda #>tests
	sta testp+1

	lda #12
	sta $e880
	lda #$10
	sta $e881

test	
	ldy #1
	; "*" on screen
	lda (testp),y

/* only needed for 1MHz 40 col screen */
#if 0
	.(
	pha	
	lda mode
	and #MODE_40COL
	cmp #MODE_40COL
	bne fast1
	pla
	pha
	cmp #$84
	bcc lower
	lda #$13
	ldx #$e8
	bne setcrtc
lower	lda #$10
	ldx #0
setcrtc	pha
	lda #12
	sta $e880
	pla
	sta $e881
	lda #13
	sta $e880
	stx $e881
fast1	pla
	.)
#endif
	sta scrptr+1
	dey
	lda (testp),y
	sta scrptr
	ora scrptr+1
	beq endloop

	ldy #2
	lda (testp),y
	eor mode
	iny
	and (testp),y
	beq notest

	ldy #0
	lda #"*"
	sta (scrptr),y

	ldy #4
	lda (testp),y
	sta scrptr
	iny
	lda (testp),y
	sta scrptr+1
	iny 
	lda (testp),y
	pha		; first parameter
	iny
	lda (testp),y
	tax		; second parameter
	iny
	lda (testp),y
	sta ptr1
	iny
	lda (testp),y
	sta ptr1+1

	pla		; restore AC, XR has 2nd param
	jsr jmpind-offset

	ldy #1
	lda (testp),y
	sta scrptr+1
	dey
	lda (testp),y
	sta scrptr
	ldy #0
	lda #" "
	sta (scrptr),y
notest
	lda #10
	clc
	adc testp
	sta testp
	bcc nopage
	inc testp+1
nopage	jmp test-offset
	.)	

	; ------------------------------
	; end of loop

endloop	clc
	inc pattrn

	; increase cycles counter (in decimal mode)
	sed
	lda #$01
	adc cycles
	sta cycles
	lda #$00
	adc cycles+1
	sta cycles+1
	lda #$00
	adc cycles+2
	sta cycles+2
	cld

	; print cycle counter on screen
	lda #$80		; scr pointer
	sta scrptr+1
	lda #$3c
	sta scrptr

	lda #$80		; REV flag
	sta revfl

	ldx #$02
l1686	lda cycles,x
	jsr hexout-offset	; l72f
	dex
	bpl l1686

l168e	jmp loop-offset	; $02a5

jmpind	jmp (ptr1)

	; -----------------------------
	; test addresses, parameters etc
tests
	; RAM $0200-$7FFF (Actually $0b00-, as it is destructive and should not overwrite this code)
	.word $8230		; "*"
	.byt 1,1
	.word $824a
	.byt >(endofprg+255), $7f ; start page, end page
	.word test_ram-offset

	; RAM $8000-$8FFF Screen memory 
	.word $8280		; "*"
	.byt 0,MODE_UPET+MODE_CSA+MODE_8296
	.word $829a
	.byt 0,16		; -, number of screen pages (4 = 4032, 8 = 80xx, 16 = 8296)
	.word test_screenmem-offset

	; RAM $8000-$87FF Screen memory 
	.word $8280		; "*"
	.byt MODE_40COL, MODE_40COL
	.word $829a
	.byt 0,8		; -, number of screen pages (4 = 4032, 8 = 80xx, 16 = 8296)
	.word test_screenmem-offset

	; RAM $8000-$83FF Screen memory 
	.word $8280		; "*"
	.byt 0, MODE_40COL
	.word $829a
	.byt 0,4		; -, number of screen pages (4 = 4032, 8 = 80xx, 16 = 8296)
	.word test_screenmem-offset

	; ROM BASIC & KERNAL
	.word $82a8		; "*"
	.byt 1,1
	.word $82c2
	.byt $b0, 4		; start page, number of 4k blocks (except EDITOR)
	.word test_rom-offset

	; ROM EDITOR
	.word $8258		; "*"
	.byt 1,1
	.word $8272
	.byt $e0, 1		; start page, number of 4k blocks (except EDITOR)
	.word test_rom-offset

	; IEEE488
	.word $8348		; "*"
	.byt 1,1
	.word $8362		; result on screen
	.byt 0,0		; parameters
	.word test_ieee-offset	; exec addr

	; Userport
	.word $8398		; "*"
	.byt 1,1
	.word $83b2		; result on screen
	.byt 0,0		; parameters
	.word test_userp-offset	; exec addr

	; 50hz
	.word $8528		; "*"
	.byt 1,1
	.word $8542		; result on screen
	.byt 0,0		; parameters
	.word test_50hz-offset	; exec addr

	; Timer 1
	.word $8488		; "*"
	.byt 1,1
	.word $84a2		; result on screen
	.byt 0,0		; parameters
	.word test_timer1-offset ; exec addr

	; Timer 1
	.word $84d8		; "*"
	.byt 1,1
	.word $84f2		; result on screen
	.byt 0,0		; parameters
	.word test_timer2-offset ; exec addr

	; CS/A Video RAM $010000 - must not cross 16 boundaries
	.word $8460		; "*"
	.byt 0,MODE_CSA
	.word $847a		; result on screen
	.byt $18,$27		; start page in bank 1, number of pages -1
	.word test_vmem-offset ; exec addr

	; CS/A Video RAM $014000 - must not cross 16 boundaries
	.word $84b0		; "*"
	.byt 0,MODE_CSA
	.word $84ca		; result on screen
	.byt $40,$3f		; start page in bank 1, number of pages-1
	.word test_vmem-offset ; exec addr

	; CS/A Video RAM $014000 - must not cross 16 boundaries
	.word $8500		; "*"
	.byt 0,MODE_CSA
	.word $851a		; result on screen
	.byt $80,$3f		; start page in bank 1, number of pages-1
	.word test_vmem-offset ; exec addr

	; CS/A Video RAM $014000 - must not cross 16 boundaries
	.word $8550		; "*"
	.byt 0,MODE_CSA
	.word $856a		; result on screen
	.byt $c0,$3f		; start page in bank 1, number of pages-1
	.word test_vmem-offset ; exec addr
#endif
	; end marker
	.word 0


	; ----------------------------------
	; output BIT: <addr>.<bit>.<type>
	; for memory error
badbitx	.(
	pha
	php
	lda #$12
	jsr chrout-offset
	txa
	jsr hexout-offset
	tya
	jsr hexout-offset
	lda #" "
	jsr chrout-offset
	lda #"W"
	plp
	bcc rderr
	.byt $2c
rderr	lda #"R"
	jsr chrout-offset
	pla
	ldy #4
	.byt $2c
	.)
	; fall-through
	; ----------------------------------
	; output BAD string with bit number
	; in: AC holds detected error bit
badbit	
	ldy #$00
	ldx #$38		; "8"
badbit2	dex			; count down bits
	asl
	bne badbit2		; on last 1-bit exit loop
	

errout	txa			; AC has bit number in ASCII

	; output BAD string with bit number / char to print in
	; AC in ASCII, Y has offset in BADSTR
	; 0  = BAD BIT: 
	; 10 = BAD ROM: UE
	; 22 = BAD
	; 26 = IEEE BAD: DIO
badout	pha
l172b	lda badstr-offset,y
	iny
	jsr chrout-offset
	bpl l172b
l1734	pla
	jsr chrout-offset
	lda #$0d
	jmp chrout-offset

	; output OK
	; only in first cycle, don't overwrite potential errors in later cycles
okout	ldy #$00
	lda cycles
	ora cycles+1
	ora cycles+2
	bne l1750		; only in first cycle
l1747	lda okstr-offset,y	; l8f5,y
	iny
	jsr chrout-offset	; l742
	bpl l1747
l1750	rts



	; ---------------------
	; used in the 50 HZ IRQ test
	; interrupt routine
irq	.(
	lda $0104,x		
	ora #$04		; set I bit in status on the stack, basically SEI
	sta $0104,x
	lda cnt
	sta ptr1
	sty ptr1+1		; y leaks through from main program
	pla
	tay
	pla
	tax
	pla
	bit $e812
	bit $e84d
	rti
	.)

	; ---------------------
okstr	.byt "O", "K"+$80
badstr	.byt $12, "BAD BIT", ":"+$80, 0
	.byt $12, "BAD ROM: P", "."+$80
	.byt $12, "BA", "D"+$80
	.byt $12, "IEEE BAD: DI", "O"+$80	; $44,$49,$cf

	; ---------------------
	; 8296 block checks

	; $fff0 values for the four blocks
l1881	.byt $80,$8c,$80
	.byt $8c
	; start page of memory to test
l1885	.byt $80,$80
	.byt $c0,$c0
	; end page of memory to test
l1889	.byt $bf
	.byt $bf,$fe,$fe

initmsg
	.byt $92		; REV OFF
	.byt "   "
	.byt "   "
	.byt "   "
	.byt $12,$20,"DIAGNOSTIC "
m_name	.byt "8032 " 
	.byt "  V4.0   "
	.byt "DATE: 08-10-2021 CYCLES: 000000 "
	.byt 13,13,13		; 
	.byt 13,13,13
	.byt 13 
	.byt " TEST: RAM 0200-7FFF",13
	.byt " TEST: RAM 8000-8FFF",
	.byt 13,13		; move down
	.byt 13,13		;
	.byt 13
	.byt " TEST: CS/A65 MMU",13
	.byt " TEST: VMEM 10000-13FFF",13
	.byt " TEST: VMEM 14000-17FFF",13
	.byt " TEST: VMEM 18000-1BFFF",13
	.byt " TEST: VMEM 1C000-1FFFF",13
	.byt 13
	.byt $13		; move back to line 7 for second column
	.byt " TEST: ROM EDITOR",13
	.byt " TEST: ROM KERNAL & BASIC"
	.byt $0d,$0d
	.byt " TEST: IEEE 488 BUS",13
	.byt " TEST: USER PORT"
	.byt $0d,$0d,$0d
	.byt " TEST: TIMER 1",13
	.byt " TEST: TIMER 2",13
	.byt " TEST: 50 HZ IRQ",13
	.byt $0d,$00

modes
m_csa	.byt "CS/A"
m_8296	.byt "8296"
m_4032	.byt "4032"
m_upet	.byt "UPET"

intvect	.byt $aa
	.byt $aa,$aa,$aa
	.byt $aa,$aa,$aa
	.byt $aa,$aa,$aa
	.byt $aa

#include "mod_memtest.a65"
#include "mod_output.a65"

#include "test_50hz.a65"
#include "test_rom.a65"
#include "test_ram.a65"
#include "test_screenmem.a65"
#include "test_timer1.a65"
#include "test_timer2.a65"
#include "test_ieee.a65"
#include "test_userport.a65"

	; CS/A65 Video card memory
#include "test_vmem.a65"

endofprg:

