
; order by preference which name should be displayed
#define	MODE_UPET	%10000000
#define	MODE_CSA	%01000000
#define	MODE_8296	%00100000
#define	MODE_40COL	%00010000
#define	MODE_2MHZ	%00001000
	

#define	SYSPORT		$efe0
#define	SYS_IRQEN	%00000010
#define	SYS_LED		%00001000

#undef	FIX

tmp1	= $20			; general temp value for XOR, or adding
ptr1	= $21			; general pointer / 16 bit counter
ptr2	= $23			; general pointer / 16 bit counter
cnt	= $25			; general 8 bit counter

mode	= $26			; bit 7: 1=2 MHz
				; bit 6: 1=8296 detected
				; bit 5: 1=CS/A MMU detected

blkno	= $27			; block number for 8x96 test
memp1	= $28			; memory test pointer
pattrn	= $2a			; memory test pattern; will be increased each cycle (starts initialized by zp mem test)
screen	= $2b			; start of screen ptr
scrptr	= $2d			; current screen pointer
lineptr	= $2f			; start of current line
cols	= $31			; number of columns
revfl	= $32			; reverse flag
cycles	= $33			; 3 byte cycle counter

testp	= $36			; pointer to current test

	.word $0400
	* = $0400

	.byt 0
	.word link
	.word 10		; line number
	.byt $9e, "4096"
	.byt 0
link	.byt $00,$00

	.dsb 4096-*, $aa

l1000	; start of program

	sei

	; disable 8x96 mapping
	lda #$60
	sta $fff0

	.(
	; clear screen
l1016	ldy #$00
	lda #$20
l101a	sta $8000,y
	sta $8100,y
	sta $8200,y
	sta $8300,y
	sta $8400,y
	sta $8500,y
	sta $8600,y
	sta $8700,y
	iny
	bne l101a
	.)

	; check zeropage and stack memory
#include "mod_zpstack.a65"

	; check target program area, copy program to $0200 and start it
#include "mod_inicopy.a65"

	

	;=======================================
	; relocated code
	;
	; the following code is copied to $0200-...

	; clear bytes 1950-1961 on 80 column screen?
l1162	
	*=$0200
	.(
	ldx #$0b
l1164	lda #$20
	sta $879e,x 
	dex
	bpl l1164
	.)

#include "mod_mode.a65"

	
	;---------------------------------------
	; to be replaced/removed
	.(
	lda mode
	and #MODE_2MHZ
	beq slow1
	; set CRTC and video
	ldy #$00
l1008	sty $e880
	lda l1150,y	; set CRTC parameters for 2MHz 80 col
	sta $e881
	iny
;	cpy #$12
	cpy #3
	bne l1008
slow1
	lda #14
	sta $e84c
	.)

	;---------------------------------------
	; all machines
l1193	lda #$60	; disable 8x96 mapping
	sta $fff0

	; init cycles counter
	lda #$00
	sta cycles
	sta cycles+1
	sta cycles+2

	; init start of screen for chrout
	lda #$80
	sta screen+1			; chrout scr hi ptr
	lda #$00
	sta screen			; chrout scr lo ptr

	; ------------------------------
	; clear screen
	lda #$93
	jsr chrout	; l742

	; ------------------------------
	; output banner message
	.(
	lda #$28		; 40 column?
	sta cols

	lda #>initmsg	;$09
	sta ptr1+1
	lda #<initmsg	;$45
	sta ptr1
	ldy #$00
l11bb	lda (ptr1),y
	beq l11d8
	pha
	cmp #$13
	bne l11cc
	; on marker, move to $258 = char 600 = MIDDLE of line 7
	; to print the right column of diag messages
	lda #$82
	sta screen+1
	lda #$58
	sta screen
l11cc	pla
	jsr chrout	; l742
	inc ptr1
	bne l11bb
l11d4	inc ptr1+1
	bne l11bb
	.)

	; ------------------------------
	; print out screen codes 0-255
l11d8	lda #$80
	sta scrptr+1	; screen ptr hi
	sta lineptr+1	; start of line
	sta screen+1	; chrout scr ptr hi
	lda #$a8
	sta scrptr	; screen ptr lo
	sta screen	; chrout scr ptr lo
	sta lineptr	; start of line
	lda #$40	; 64 columns?
	sta cols

	ldy #$00
	ldx #$00
l11f0	txa
	sta (scrptr),y	; store value on screen
	inx
	inc scrptr
	bne l11fa
l11f8	inc scrptr+1
l11fa	txa
	and #$3f	; end of line (64 values/line)
	bne l11f0

l11ff	lda #$0d
	jsr chrout	;l742
	txa
	bne l11f0

	; ------------------------------
	; set IRQ routine

        ; set interrupt pointer to 08db
        lda #<irq        ; $db
        sta $90
        lda #>irq        ; $08
        sta $91

	; ------------------------------
	; test loop

loop	.(
	lda #<tests
	sta testp
	lda #>tests
	sta testp+1

	lda #12
	sta $e880
	lda #$10
	sta $e881

test	
	ldy #1
	; "*" on screen
	lda (testp),y

/* only needed for 1MHz 40 col screen */
#if 0
	.(
	pha	
	lda mode
	and #MODE_40COL
	cmp #MODE_40COL
	bne fast1
	pla
	pha
	cmp #$84
	bcc lower
	lda #$13
	ldx #$e8
	bne setcrtc
lower	lda #$10
	ldx #0
setcrtc	pha
	lda #12
	sta $e880
	pla
	sta $e881
	lda #13
	sta $e880
	stx $e881
fast1	pla
	.)
#endif
	sta scrptr+1
	dey
	lda (testp),y
	sta scrptr
	ora scrptr+1
	beq endloop

	ldy #2
	lda (testp),y
	eor mode
	iny
	and (testp),y
	beq notest

	ldy #0
	lda #"*"
	sta (scrptr),y

	ldy #4
	lda (testp),y
	sta scrptr
	iny
	lda (testp),y
	sta scrptr+1
	iny 
	lda (testp),y
	pha		; first parameter
	iny
	lda (testp),y
	tax		; second parameter
	iny
	lda (testp),y
	sta ptr1
	iny
	lda (testp),y
	sta ptr1+1

	pla		; restore AC, XR has 2nd param
	jsr jmpind

	ldy #1
	lda (testp),y
	sta scrptr+1
	dey
	lda (testp),y
	sta scrptr
	ldy #0
	lda #" "
	sta (scrptr),y
notest
	lda #10
	clc
	adc testp
	sta testp
	bcc nopage
	inc testp+1
nopage	jmp test
	.)	

	; ------------------------------
	; end of loop

endloop	clc
	inc pattrn

	; increase cycles counter (in decimal mode)
	sed
	lda #$01
	adc cycles
	sta cycles
	lda #$00
	adc cycles+1
	sta cycles+1
	lda #$00
	adc cycles+2
	sta cycles+2
	cld

	; print cycle counter on screen
	lda #$80		; scr pointer
	sta scrptr+1
	lda #$3c
	sta scrptr

	lda #$80		; REV flag
	sta revfl

	ldx #$02
l1686	lda cycles,x
	jsr hexout	; l72f
	dex
	bpl l1686

l168e	jmp loop	; $02a5

jmpind	jmp (ptr1)

	; -----------------------------
	; test addresses, parameters etc
tests
	; RAM $0200-$7FFF (Actually $0b00-, as it is destructive and should not overwrite this code)
	.word $8230		; "*"
	.byt 1,1
	.word $824a
	.byt >(endofprg+255), $7f ; start page, end page
	.word test_ram

	; RAM $8000-$8FFF Screen memory 
	.word $8280		; "*"
	.byt 0,MODE_UPET+MODE_CSA+MODE_8296
	.word $829a
	.byt 0,16		; -, number of screen pages (4 = 4032, 8 = 80xx, 16 = 8296)
	.word test_screenmem

	; RAM $8000-$87FF Screen memory 
	.word $8280		; "*"
	.byt MODE_40COL, MODE_40COL
	.word $829a
	.byt 0,8		; -, number of screen pages (4 = 4032, 8 = 80xx, 16 = 8296)
	.word test_screenmem

	; RAM $8000-$83FF Screen memory 
	.word $8280		; "*"
	.byt 0, MODE_40COL
	.word $829a
	.byt 0,4		; -, number of screen pages (4 = 4032, 8 = 80xx, 16 = 8296)
	.word test_screenmem

	; ----
	; 8296 block tests
	.word $82d0		; "*"
	.byt 0, MODE_8296
	.word $82ea
	.byt 0,0		; blockno
	.word test_8296

	.word $8320		; "*"
	.byt 0, MODE_8296
	.word $833a
	.byt 1,0		; blockno
	.word test_8296

	.word $8370		; "*"
	.byt 0, MODE_8296
	.word $838a
	.byt 2,0		; blockno
	.word test_8296

	.word $83c0		; "*"
	.byt 0, MODE_8296
	.word $83da
	.byt 3,0		; blockno
	.word test_8296

	; 8296 FPLA MMU
	; note: needs to be _after_ 8296 block tests, as they init some memory tested here
	.word $8410		; "*"
	.byt 0, MODE_8296
	.word $842a
	.byt 0,0		; blockno
	.word test_fpla

	; ----
	; ROM BASIC & KERNAL
	.word $82a8		; "*"
	.byt 1,1
	.word $82c2
	.byt $b0, 4		; start page, number of 4k blocks (except EDITOR)
	.word test_rom

	; ROM EDITOR
	.word $8258		; "*"
	.byt 1,1
	.word $8272
	.byt $e0, 1		; start page, number of 4k blocks (except EDITOR)
	.word test_rom

	; IEEE488
	.word $8348		; "*"
	.byt 1,1
	.word $8362		; result on screen
	.byt 0,0		; parameters
	.word test_ieee	; exec addr

	; Userport
	.word $8398		; "*"
	.byt 1,1
	.word $83b2		; result on screen
	.byt 0,0		; parameters
	.word test_userp	; exec addr

	; 50hz
	.word $8528		; "*"
	.byt 1,1
	.word $8542		; result on screen
	.byt 0,0		; parameters
	.word test_50hz	; exec addr

	; Timer 1
	.word $8488		; "*"
	.byt 1,1
	.word $84a2		; result on screen
	.byt 0,0		; parameters
	.word test_timer1 ; exec addr

	; Timer 1
	.word $84d8		; "*"
	.byt 1,1
	.word $84f2		; result on screen
	.byt 0,0		; parameters
	.word test_timer2 ; exec addr

	; ----
	; CS/A Video RAM $010000 - must not cross 16 boundaries
	.word $8460		; "*"
	.byt 0,MODE_CSA
	.word $847a		; result on screen
	.byt $18,$27		; start page in bank 1, number of pages -1
	.word test_vmem ; exec addr

	; CS/A Video RAM $014000 - must not cross 16 boundaries
	.word $84b0		; "*"
	.byt 0,MODE_CSA
	.word $84ca		; result on screen
	.byt $40,$3f		; start page in bank 1, number of pages-1
	.word test_vmem ; exec addr

	; CS/A Video RAM $014000 - must not cross 16 boundaries
	.word $8500		; "*"
	.byt 0,MODE_CSA
	.word $851a		; result on screen
	.byt $80,$3f		; start page in bank 1, number of pages-1
	.word test_vmem ; exec addr

	; CS/A Video RAM $014000 - must not cross 16 boundaries
	.word $8550		; "*"
	.byt 0,MODE_CSA
	.word $856a		; result on screen
	.byt $c0,$3f		; start page in bank 1, number of pages-1
	.word test_vmem ; exec addr
#endif
	; end marker
	.word 0


	; ----------------------------------
	; output BIT: <addr>.<bit>.<type>
	; for memory error
badbitx	.(
	pha
	php
	lda #$12
	jsr chrout
	txa
	jsr hexout
	tya
	jsr hexout
	lda #" "
	jsr chrout
	lda #"W"
	plp
	bcc rderr
	.byt $2c
rderr	lda #"R"
	jsr chrout
	pla
	ldy #4
	.byt $2c
	.)
	; fall-through
	; ----------------------------------
	; output BAD string with bit number
	; in: AC holds detected error bit
badbit	
	ldy #$00
	ldx #$38		; "8"
badbit2	dex			; count down bits
	asl
	bne badbit2		; on last 1-bit exit loop
	

errout	txa			; AC has bit number in ASCII

	; output BAD string with bit number / char to print in
	; AC in ASCII, Y has offset in BADSTR
	; 0  = BAD BIT: 
	; 10 = BAD ROM: UE
	; 22 = BAD
	; 26 = IEEE BAD: DIO
badout	pha
l172b	lda badstr,y
	iny
	jsr chrout
	bpl l172b
l1734	pla
	jsr chrout
	lda #$0d
	jmp chrout

	; output OK
	; only in first cycle, don't overwrite potential errors in later cycles
okout	ldy #$00
	lda cycles
	ora cycles+1
	ora cycles+2
	bne l1750		; only in first cycle
l1747	lda okstr,y	; l8f5,y
	iny
	jsr chrout	; l742
	bpl l1747
l1750	rts



	; ---------------------
	; used in the 50 HZ IRQ test
	; interrupt routine
irq	.(
	lda $0104,x		
	ora #$04		; set I bit in status on the stack, basically SEI
	sta $0104,x
	lda cnt
	sta ptr1
	sty ptr1+1		; y leaks through from main program
	pla
	tay
	pla
	tax
	pla
	bit $e812
	bit $e84d
	rti
	.)

	; ---------------------
okstr	.byt "O", "K"+$80
badstr	.byt $12, "BAD BIT", ":"+$80, 0
	.byt $12, "BAD ROM: P", "."+$80
	.byt $12, "BA", "D"+$80
	.byt $12, "IEEE BAD: DI", "O"+$80	; $44,$49,$cf

	; CRTC init parameter
l1150 	.byt 126, 80, 100


initmsg
	.byt $92		; REV OFF
	.byt "   "
	.byt "   "
	.byt "   "
	.byt $12,$20,"DIAGNOSTIC "
m_name	.byt "8032 " 
	.byt "  V4.0   "
	.byt "DATE: 08-10-2021 CYCLES: 000000 "
	.byt 13,13,13		; 
	.byt 13,13,13
	.byt 13 
	.byt " TEST: RAM 0200-7FFF",13
	.byt " TEST: RAM 8000-8FFF",
	.byt 13
	.byt " TEST: 8X96 BLOCK 0",13
	.byt " TEST: 8X96 BLOCK 1",13
	.byt " TEST: 8X96 BLOCK 2",13
	.byt " TEST: 8X96 BLOCK 3",13
	.byt " TEST: FPLA II",13
	.byt " TEST: VMEM 10000-13FFF",13
	.byt " TEST: VMEM 14000-17FFF",13
	.byt " TEST: VMEM 18000-1BFFF",13
	.byt " TEST: VMEM 1C000-1FFFF",13
	.byt 13
	.byt $13		; move back to line 7 for second column
	.byt " TEST: ROM EDITOR",13
	.byt " TEST: ROM KERNAL & BASIC"
	.byt $0d,$0d
	.byt " TEST: IEEE 488 BUS",13
	.byt " TEST: USER PORT"
	.byt $0d,$0d,$0d
	.byt " TEST: TIMER 1",13
	.byt " TEST: TIMER 2",13
	.byt " TEST: 50 HZ IRQ",13
	.byt $0d,$00

modes
m_csa	.byt "CS/A"
m_8296	.byt "8296"
m_4032	.byt "4032"
m_upet	.byt "UPET"

intvect	.byt $aa
	.byt $aa,$aa,$aa
	.byt $aa,$aa,$aa
	.byt $aa,$aa,$aa
	.byt $aa

#include "mod_memtest.a65"
#include "mod_output.a65"

#include "test_50hz.a65"
#include "test_rom.a65"
#include "test_ram.a65"
#include "test_screenmem.a65"
#include "test_timer1.a65"
#include "test_timer2.a65"
#include "test_ieee.a65"
#include "test_userport.a65"

	; 8296 extra memory and FPLA MMU
#include "test_8296.a65"
#include "test_fpla.a65"

	; CS/A65 Video card memory
#include "test_vmem.a65"

endofprg:

